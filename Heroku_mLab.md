
# 1. Working first time with Heroku

Heroku is a cloud platform that lets companies build, deliver, monitor and scale apps — as the say: 

> we're the fastest way to go from idea to URL, bypassing all those infrastructure headaches.

## 1.1 Set up

Download the Heroku CLI for Mac OS X (or the OS you choose), install it nad create an account.

Once installed, you can use the heroku command from your command shell.

Log in using the email address and password you used when creating your Heroku account:

`$ heroku login`

Enter your Heroku credentials.
Email: zeke@exxxx.com
Password: xxxx

After authenticatoon you can use both the heroku and git commands to operate.

Now check if you have the prerequisites installed properly. Npm. node and git.

Check using this commands:

`$ node -v` => v5.9.1 (for example)

`$ npm -v` => 3.7.3 (for example)

`$ git --version` => git version 2.2.1

## 1.2. Prepare the app

In this step, you will prepare a simple application that can be deployed. In this case we are going to test our ToDo app.

You can clone it in this way:

`$ git clone https://github.com/joseangelbarrera/todo-list.git`

And then go to the folder:

`$ cd todo-list`

You now have a functioning git repository that contains our simple toDo application as well as a package.json file, which is used by Node’s dependency manager.

## 1.3. Deploy the app

In this step you will deploy the app to Heroku.
Create an app on Heroku, which prepares Heroku to receive your source code.

`$ heroku create`

the response will be somethig similar to:

```
Creating app... done, ⬢ powerful-refuge-99970
https://powerful-refuge-99970.herokuapp.com/ | https://git.heroku.com/powerful-refuge-99970.git
```

When you create an app, a git remote (called heroku) is also created and associated with your local git repository.

Heroku generates a random name (in this case powerful-refuge-99970) for your app, or **you can pass a parameter** to specify your own app name. But a name must start with a letter and can only contain lowercase letters, numbers, and dashes

For example:

`$ heroku create todolist2107`

```
Creating ⬢ todolist2107... done
https://todolist2107.herokuapp.com/ | https://git.heroku.com/todolist2107.git
```

Now deploy your code:

`$ git push heroku master`

The application is now deployed. Ensure that at least one instance of the app is running:

`$ heroku ps:scale web=1`

Now visit the app at the URL generated by its app name. As a handy shortcut, you can open the website as follows:

`$ heroku open`

## 1.4. View logs

Heroku treats logs as streams of time-ordered events aggregated from the output streams of all your app and Heroku components, providing a single channel for all of the events.

View information about your running app using one of the logging commands, heroku logs --tail:

`$ heroku logs --tail`

```
2011-03-10T10:22:30-08:00 heroku[web.1]: State changed from created to starting
2011-03-10T10:22:32-08:00 heroku[web.1]: Running process with command: `node index.js`
2011-03-10T10:22:33-08:00 heroku[web.1]: Listening on 18320
2011-03-10T10:22:34-08:00 heroku[web.1]: State changed from starting to up
Visit your application in the browser again, and you’ll see another log message generated.
```

Press `Control+C to stop streaming the logs.


## 1.6. Define a Procfile

Use a Procfile file. It should be named **Procfile** exactly, and not anything else. For example, Procfile.txt is not valid. The file should be a simple text file.

The file must be placed in the root directory of your application.
The Procfile in the example app you deployed looks like this:

`web: node index.js`

Also you can specify the addres into the packcage.jason file creating differents scripts as:

```
"scripts": {
    "start": "node index.js",
    "dev": "nodemon index",
  },
```

## 1.7. Run the app locally
Now start your application locally using the heroku local command, which was installed as part of the Heroku CLI:

`$ heroku local web`

Just like `Heroku`, `heroku local` examines the Procfile to determine what to run. In this case `web`.

Open http://localhost:5000 with your web browser. You should see your app running locally.

To stop the app from running locally, in the CLI, press `Ctrl`+`C` to exit.


# 2. Managging app changes :

To propagate a local change to the application through to Heroku when modify the application follow those steps:

## 2.1. Visit your local app

`$ heroku local`

## 2.2. Deploy you app
Add the modified files to the local git repository:

`$ git add .`

## 2.3. Commit changes
Now commit the changes to the repository:

`$ git commit -m "Demo"`

## 2.4. Push changes
Now deploy, just as you did previously:

`$ git push heroku master`

## 2.4. Open to test
Finally, check that everything is working:

`$ heroku open cool`


# 3. Define config vars

## 3.1 Using the shell

Heroku manifests ***config vars as environment variables*** to the application. These environment variables are persistent – they will remain in place across deploys and app restarts – so unless you need to change values, you only need to set them once.

Whenever you set or remove a config var, ***your app will be restarted***.

Use the Heroku CLI’s config to manage your config vars:

|config:set|config:get|config:unset|
|:---:|:---:|:---:|

```
$ heroku config:set GITHUB_USERNAME=joesmith
Adding config vars and restarting myapp... done, v12
GITHUB_USERNAME: joesmith

$ heroku config
GITHUB_USERNAME: joesmith
OTHER_VAR:    production

$ heroku config:get GITHUB_USERNAME
joesmith

$ heroku config:unset GITHUB_USERNAME
Unsetting GITHUB_USERNAME and restarting myapp... done, v13

```

## 3.2 Using the app

Heroku lets you externalise configuration - storing data such as encryption keys or external resource addresses in config vars. Config vars are exposed as environment variables to the application. For example, you can modify index.js so that it introduces a new route.

In Node.js, use `process.env` to access environment variables:

Heroku local will automatically set up the environment based on the contents of the .env file in your local directory. 

```
DB_URL=mongodb://localhost:27017/test
PORT=3000
```

View the config vars that are set using heroku config:

$ heroku config

You can also edit config vars on your app’s settings tab on Dashboard.


## 3.3 Install npm dotenv

Dotenv is a zero-dependency module that loads environment variables from a .env file into process.env. Storing configuration in the environment separate from code is based on [The Twelve-Factor App methodology](https://12factor.net/dev-prod-parity).

If you `npm install` something with `--save` or `--save-dev`, it will install and it will put it in the right place within your package.json file

`npm install dotenv --save-dev`

into the app.js file include:

`process.env.PORT` prepares the app in order the PORT could be established from the environment variable, which you can establish with a new file called '.env'. So you must create the file '.env' as follow:


/////////
/////////
/////////
/////////
/////////
/////////
/////////
/////////
/////////
/////////



## 10º Provision a database
We use mLab to create our first database in https://mlab.com with those two steps:

- Step 1: Set up a mLab account
- Step 2: Create a database subscription and add a user

After them connect to your new database:

Once you finish the setup mLab provide two ways ***to connect***:

***Using the mongo shell:***

`@ mongo ds151631.mlab.com:51631/todo_list -u <dbuser> -p <dbpassword>`
`
***Uusing a driver via the standard MongoDB URI (what's this?):
***
`mongodb://<dbuser>:<dbpassword>@ds151631.mlab.com:51631/todo_list`

> db user: is the user you have created
> db password: is the pass you create for your user.


Stablish enviroments variables with the shell.


`$ heroku config:set NODE_ENV=production`


`$ heroku config:set DB_URI=mongodb://<db_user>:<db_password>@ds045715.mlab.com:45715/<db_name> `

(Remember, these environment variables are persistent)



mongo ds151631.mlab.com:51631/todo_list -u admin -p bmp509

Adding data

```
    var toDo_Schema = new Schema({
    task: String,
    dateOfCreation: {
        type: Number,
        default: +new Date
    },
    dateOfUpdate: Number,
    completed: {
        type: Boolean, 
        default: false
     }
})
```


curl -X POST --data "task=Get involved in the revolution" localhost:4000/tasks
  

curl -X POST --data "task=Ask Questions&Completed=True" localhost:4000/tasks



% mongo ds012345.mlab.com:56789/dbname -u dbuser -p dbpassword




////


`web: node index.js`

Also you can specify the addres into the packcage.jason file creating differents scripts as:

```
"scripts": {
    "start": "node server/app",
    "dev": "nodemon server/app",
    "dev:debug": "DEBUG=*,-express:router*,-nodemon* npm run dev"
  },
```


///

Check if npm config production value is set to true. If this value is true, it will skip over the dev dependencies.

Run npm config get production



Whit database:

IN case 

```
if (process.env.NODE_ENV !== 'production') {
  require('dotenv').config()
}

const dbUrl = process.env.DB_URL
const PORT = process.env.PORT
```


